
format-string:
- test using %p (lot of %p) to print out value from registers & stack
- for function parameters & x64 binary, first 5 %p prints parameters as belong in registers, 6 and above %p prints stack value
- for example, if 8'th %p prints value that we want (eq; libc system() addr), then we don't need to do %p eight times, just specify
  %8$p, which means print %p on the 8'th parameter
- if we want to print large string into stdout, we don't need to write "000000000..", just use %150u and it will print hundred-fifty "0"
- if we want to write-what-where primitive, the trick is:
    - include the address into the format string, "\x41\x41\x41\x41 %1$hn"
    - assume that 1'th data on stack is 0x41414141, we treat it as an address, and ask %1$hn to write our address theere
    - %hn means to write (2 byte), instead of regular %n (which just write 1-byte)
- if we want to read-primitive from format-string attack, we just:
    - include the address into the format string, "\x41\x41\x41\x41 %1$hn"
    - assume that 1'th data on stack is 0x41414141, we treat it as an address, and ask "<%1$s>" to read from that address
    - %s read data from that address, so it will read data from 0x41414141
    - why put into "< >", because it is easy to parse it that way :)
- remember, that printf() just read until null-byte, if GOT address have null-byte, put it as the last data inside format string
- NOTE: if full-RELRO activated, we can't write into GOT, it must be only "Partial", check using `checksec`

buffer-overflow:
- generate large input and see if EIP was overwritten
- to identify in which buffer contains new overwritte EIP, uses cyclic to generate random string with pattern
    - `cyclic 100` which 100 is length
- replace overwritten bytes in cyclic's output string with address of EIP we want to overwrite
- can be use with return-to-libc, where we call system() with "/bin/sh" as our parameter there
    - usually binary with libc library will have "/bin/sh" string inside it
    - `search-pattern /bin` using GEF
- or we can use shellcode, the trick is to jump to the $esp address
    - the trick is to find an address which do `jmp $esp`
    - find it using 
        1)  `assemble "jmp esp"` to get opcode for `jmp esp`
        2) search for an address inside memory for pattern, eq; \xff\xe4 -> `seach-pattern 0xffe4`
        3) overwrite $eip with address that do `jmp esp`
    - to generate good shellcode, use mfsvenom
        - `msfvenom -f python -p linux/x64/exec -a x86_64 -b '\x00\x0a\x0d'`

rop:
- if binary has DEP enable, we need to use ROP
    - generate automatic rop chain
        - `./ROPgadget.py --binary sample --ropchain`
    - same technique as buffer-overflow
    - instead of overwritting EIP ourself, use one generated by `ropgadget`

c/c++ static analysis:
- run `flawfinder <c/c++ src code folder>`
